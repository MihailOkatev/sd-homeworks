# Задание повышенной сложности к лекции «Интернет — большая библиотека»

## Циклы. Подробнее

Для работы цикла необходима переменная-счётчик. Она используется для подсчёта количества _итераций_ — витков цикла. Переменную-счётчик принято называть одной буквой `i`.

При создании нового цикла есть 3 важных компонента:
* *Начало* — с какими данными цикл запустится в первый раз; отправная точка.
* *Условие* — пока условие возвращает `true`, цикл продолжает работу. Как только условие возвращает `false`, цикл прекращает свою работу.
* *Шаг* — как меняется переменная-счётчик на каждой итерации. Она может уменьшаться или увеличиваться.

Самый часто встречающийся цикл:
```javascript
for (let i = 0; i < variable; i++) {
 // тело цикла
}
```

В примере выше *началом* является часть `let i = 0`. Мы объявляем переменную-счётчик и «говорим», что она будет равна 0 на старте.

*Условие* `i < variable` указывает, что цикл будет работать, пока `i` меньше значения, хранящегося в переменной `variable`. 

На каждой итерации цикла переменная-счётчик будет увеличиваться на 1 — `i++`.

Таким образом, на первом витке `i` будет равна 0, на втором — 1, на третьем — 2 и так далее.

Подробнее о циклах в [справочнике по JavaScript](https://learn.javascript.ru/while-for). 

### Инкремент

Увеличение значения переменной на 1 — одна из самых частых операций в программировании. 
Чтобы каждый раз не писать `i = i + 1` была придумана сокращённая запись `i++`. 

Подробнее про инкремент в [справочнике JavaScript](https://learn.javascript.ru/operators#inkrement-dekrement).

## Заполняем массив

Переменная-счётчик может использоваться не только для работы цикла. Например, она очень удобна при работе с массивами. 

Поскольку счётчик начинается с 0, как и отсчёт элементов в массиве, и увеличивается постепенно, как и индексы в массиве, то мы можем _перебрать_ элементы массива один за другим всего в одну строку.

```javascript
let arr = ["один", "два", "три", "четыре", "пять"];

for (let i = 0; i < arr.length; i++) {
 console.log(arr[i]);
}
```

Результат:
```text
> "один" 
> "два" 
> "три" 
> "четыре" 
> "пять"
```

В условии цикла мы указали, что цикл должен работать до тех пор, пока `i` не сравняется с длиной массива.

Поскольку на каждой итерации `i` будет увеличиваться на 1, то в голове мы можем представить следующий порядок действий:
* Итерация 1: `i` равна 0, строка `console.log(arr[i])` преобразуется в `console.log(arr[0]);`
* Итерация 2: `i` равна 1, строка `console.log(arr[i])` преобразуется в `console.log(arr[1]);`
* Итерация 3: `i` равна 2, строка `console.log(arr[i])` преобразуется в `console.log(arr[2]);`

И так далее. 

Таким образом мы можем не только «прочитать» элементы массива, но и записать значения в массив. На каждой итерации цикла новый элемент будет записываться на свой индекс, отличающийся от предыдущего на 1.

## Запись элементов в массив

Бывает, что нам нужно создать массив динамически, наполнив его значениями, полученными в процессе работы кода. Или изначально мы можем не знать длину массива и, как следствие, не можем наполнить массив элементами в момент создания. 

Для записи элементов в массив чаще всего используются два метода.

### Запись по индексу 

Если мы знаем конкретный индекс, на который нужно записать элемент, то можем просто присвоить значение:

```javascript
let arr = [];

arr[0] = "номер 1";
arr[1] = "номер 2";

console.log(arr); // <-- ["номер 1", "номер 2"]
```

При работе с большими массивами этот способ крайне нежелателен, поскольку вы можете случайно перезаписать уже существующий элемент массива вместо того, чтобы добавить новый. Это грозит потерей данных. 

Но, например, внутри цикла такая запись может быть очень удобна.

### `push()`

Метод `push()` помещает новый элемент в конец массива.

```javascript
let arr = [];

arr.push("первый элемент");
arr.push("второй элемент");

console.log(arr); // <-- ["первый элемент", "второй элемент"]
```

Этот способ максимально безопасен при работе с большими массивами. Новый элемент точно будет добавлен на новый индекс в конце массива, и никакие данные не будут потеряны. 

Подробнее о методе `push()` в [справочнике по JavaScript](https://learn.javascript.ru/array#metody-pop-push-shift-unshift).
______

## Легенда

Apple опять выпускает новый iPhone. Вы пытаетесь убедить себя, что он вам не нужен, но соблазн очень велик. Вы решаете пойти рациональным путём и написать небольшую программу, которая наглядно покажет, сколько условных дошираков можно купить за цену нового iPhone. 

Возможно, так ваш мозг согласится, что это бесполезная и дорогая покупка =) 

## Задача

1. Цена нового iPhone 99 990 рублей. Запишите цену в качестве значения одной из констант. Которой из двух решите самостоятельно, ориентируясь на название переменной и код, написанный ниже. 
2. Усреднённая цена лапши быстрого приготовления — 18 рублей. Запишите эту цену в качестве значения второй константы. 
3. Рассчитайте, сколько упаковок лапши можно купить за цену iPhone. Запишите получившийся результат в переменную `howMuchNoodles`. Помните, что мы можем купить только целые упаковки. 
4. Посчитайте, какая сдача останется. Запишите результат в переменную `change`.
5. Напишите управляющую конструкцию так, чтобы строка о сдаче выводилась в консоль, только если после покупки остаётся сдача. 
6. Напишите цикл, который будет заполнять массив символами `#`. Переменная-счётчик на старте равна нулю, увеличивается на каждой итерации на 1 и не должна быть больше, чем количество купленных упаковок. 
7. Внутри цикла напишите операцию присвоения. В левой части будет `noodlesArray[i]`, в правой — символ `#`.
8. После цикла выведите в консоль склейку элементов массива `noodlesArray`. 

_Склеивать массив мы учились в прошлом задании повышенной сложности._

### Ссылка на исходный код
https://repl.it/@netologySD/loopsandif

## Правильное решение (с комментариями)

```javascript
const iphonePrice = 99990;
const noodlesPrice = 18;

let howMuchNoodles = Math.floor(iphonePrice / noodlesPrice); // кол-во дошираков 
// Метод Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.

let change = iphonePrice % noodlesPrice; // записываем остаток от деления при помощи оператора %

console.log("Вместо нового iPhone можно купить: ");
console.log(howMuchNoodles + " дошираков");

if (change > 0) { // если значение в переменной "change" больше 0, выведем в консоль сообщение
  console.log("Ещё останется " + change + " рублей");
}

console.log("Это вот столько 👇");

let noodlesArray = [];

for(let i = 0; i < howMuchNoodles; i++) { // выполняем выражение в теле цикла, 
//пока значение в переменной i меньше количества дошираков

  noodlesArray[i] = '#'; // присваиваем элементу массива под индексом i символ "#"

}

console.log(noodlesArray.join(''));
```

## Возможные проблемы и замечания

Несмотря на то, что количество итераций цикла будет равно количеству в переменной `howMuchNoodles`, сам цикл остановится не включая последнее число. Для такой записи последним числом будет 999, а не 1000: 
   
_Код_: 
```javascript
 for(let i = 0; i < 1000; i++) {
     console.log(i) // 0, 1, 2 ... 998, 999
 }
```
Этому есть объяснение. Коротко опишем работу цикла: 

1. Сначала создаётся переменная `i` и в неё присваивается установленное значение
2. Далее цикл переходит к выражению `i < 1000`. Выражение может преобразоваться либо в `False`, либо в `True`.
3. Если `True` выполняется код в теле цикла ( внутри `{}`)
4. После чего выполняется выражение `i++`. 
5. смотри пункт 1
6. Если `False` цикл завершает работу.

Когда переменная `i` равна 1000, условие `i < 1000` выдаст `False`, и цикл завершит работу на 999.
